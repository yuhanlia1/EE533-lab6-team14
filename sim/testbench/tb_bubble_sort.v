`timescale 1ns/1ps

// ============================================================================
//  tb_bubble_gcc.v
//  Testbench for bubble_gcc.s (GCC Bubble Sort)
//  Generated by rv32i_asm.py
//
//  Memory Layout:
//    RODATA_BASE = 0x0400 → Dcache word 256 (.LC0 input array)
//    STACK_TOP   = 0x0300 = 768 (sp initial value, set at program start)
//    Sort Results  → Dcache word 180..185
//                  (On stack: s0≈764, array_base=s0-44=720, word=720/4=180)
//
//  HALT: ret replaced by beq x0,x0,0, byte PC = 1080 (slot 270)
// ============================================================================

module tb_pipeline_datapath;

// -----------------------------------------------------------------------------
//  Parameters
// -----------------------------------------------------------------------------
parameter CLK_PERIOD = 10;
parameter ARR_LEN    = 6;
parameter MAX_CYCLES = 50000;

// Key addresses from assembler output
localparam [10:0] HALT_BYTE_PC  = 11'd1080;  // slot 270
localparam integer RODATA_WORD  = 256;        // Dcache word 256 (.LC0)
localparam integer RESULT_WORD  = 180;        // Dcache word 180 (Sorted results)

// -----------------------------------------------------------------------------
//  Clock & Reset
// -----------------------------------------------------------------------------
reg clk, rst;
initial clk = 0;
always #(CLK_PERIOD/2) clk = ~clk;

// -----------------------------------------------------------------------------
//  DUT (Device Under Test)
// -----------------------------------------------------------------------------
pipeline_datapath dut (
    .clk (clk),
    .rst (rst)
);

// Cycle Counter
integer cycle_cnt;
initial cycle_cnt = 0;
always @(posedge clk) cycle_cnt = cycle_cnt + 1;

integer i;
reg signed [31:0] input_snapshot [0:ARR_LEN-1];

// ============================================================================
//  Task: load_icache
//  Automatically generated by rv32i_asm.py from bubble_gcc.s
//  91 insts, 273 slots, HALT byte PC=1080
// ============================================================================
task load_icache;
integer _ki;
begin
    for (_ki = 0; _ki < 512; _ki = _ki + 1)
        dut.Imm.mem[_ki] = 32'h00000013; // NOP

    // -- startup stub: li sp, 0x300 --
    dut.Imm.mem[  0] = 32'h30000113; // addi sp,x0,768
    dut.Imm.mem[  1] = 32'h00000013; // NOP
    dut.Imm.mem[  2] = 32'h00000013; // NOP
    // -- <main> (byte 12) --
    dut.Imm.mem[  3] = 32'hFF810113; // addi sp,sp,-8
    dut.Imm.mem[  4] = 32'h00000013; // NOP
    dut.Imm.mem[  5] = 32'h00000013; // NOP
    dut.Imm.mem[  6] = 32'h00812023; // sw s0,0(sp)
    dut.Imm.mem[  7] = 32'h00000013; // NOP
    dut.Imm.mem[  8] = 32'h00000013; // NOP
    dut.Imm.mem[  9] = 32'h00112223; // sw ra,4(sp)
    dut.Imm.mem[ 10] = 32'h00000013; // NOP
    dut.Imm.mem[ 11] = 32'h00000013; // NOP
    dut.Imm.mem[ 12] = 32'h00410413; // addi s0,sp,4
    dut.Imm.mem[ 13] = 32'h00000013; // NOP
    dut.Imm.mem[ 14] = 32'h00000013; // NOP
    dut.Imm.mem[ 15] = 32'hFD810113; // addi sp,sp,-40
    dut.Imm.mem[ 16] = 32'h00000013; // NOP
    dut.Imm.mem[ 17] = 32'h00000013; // NOP
    dut.Imm.mem[ 18] = 32'h000006B7; // lui a3,%hi(.LC0)   → imm=0
    dut.Imm.mem[ 19] = 32'h00000013; // NOP
    dut.Imm.mem[ 20] = 32'h00000013; // NOP
    dut.Imm.mem[ 21] = 32'h40068693; // addi a3,a3,%lo(.LC0) → imm=1024=0x400
    dut.Imm.mem[ 22] = 32'h00000013; // NOP
    dut.Imm.mem[ 23] = 32'h00000013; // NOP
    dut.Imm.mem[ 24] = 32'hFD440293; // addi t0,s0,-44
    dut.Imm.mem[ 25] = 32'h00000013; // NOP
    dut.Imm.mem[ 26] = 32'h00000013; // NOP
    dut.Imm.mem[ 27] = 32'h00068093; // mv ra,a3
    dut.Imm.mem[ 28] = 32'h00000013; // NOP
    dut.Imm.mem[ 29] = 32'h00000013; // NOP
    dut.Imm.mem[ 30] = 32'h0000A503; // lw a0,0(ra)
    dut.Imm.mem[ 31] = 32'h00000013; // NOP
    dut.Imm.mem[ 32] = 32'h00000013; // NOP
    dut.Imm.mem[ 33] = 32'h0040A583; // lw a1,4(ra)
    dut.Imm.mem[ 34] = 32'h00000013; // NOP
    dut.Imm.mem[ 35] = 32'h00000013; // NOP
    dut.Imm.mem[ 36] = 32'h0080A603; // lw a2,8(ra)
    dut.Imm.mem[ 37] = 32'h00000013; // NOP
    dut.Imm.mem[ 38] = 32'h00000013; // NOP
    dut.Imm.mem[ 39] = 32'h00C0A683; // lw a3,12(ra)
    dut.Imm.mem[ 40] = 32'h00000013; // NOP
    dut.Imm.mem[ 41] = 32'h00000013; // NOP
    dut.Imm.mem[ 42] = 32'h01008093; // addi ra,ra,16
    dut.Imm.mem[ 43] = 32'h00000013; // NOP
    dut.Imm.mem[ 44] = 32'h00000013; // NOP
    dut.Imm.mem[ 45] = 32'h00A2A023; // sw a0,0(t0)
    dut.Imm.mem[ 46] = 32'h00000013; // NOP
    dut.Imm.mem[ 47] = 32'h00000013; // NOP
    dut.Imm.mem[ 48] = 32'h00B2A223; // sw a1,4(t0)
    dut.Imm.mem[ 49] = 32'h00000013; // NOP
    dut.Imm.mem[ 50] = 32'h00000013; // NOP
    dut.Imm.mem[ 51] = 32'h00C2A423; // sw a2,8(t0)
    dut.Imm.mem[ 52] = 32'h00000013; // NOP
    dut.Imm.mem[ 53] = 32'h00000013; // NOP
    dut.Imm.mem[ 54] = 32'h00D2A623; // sw a3,12(t0)
    dut.Imm.mem[ 55] = 32'h00000013; // NOP
    dut.Imm.mem[ 56] = 32'h00000013; // NOP
    dut.Imm.mem[ 57] = 32'h01028293; // addi t0,t0,16
    dut.Imm.mem[ 58] = 32'h00000013; // NOP
    dut.Imm.mem[ 59] = 32'h00000013; // NOP
    dut.Imm.mem[ 60] = 32'h0000A503; // lw a0,0(ra)
    dut.Imm.mem[ 61] = 32'h00000013; // NOP
    dut.Imm.mem[ 62] = 32'h00000013; // NOP
    dut.Imm.mem[ 63] = 32'h0040A583; // lw a1,4(ra)
    dut.Imm.mem[ 64] = 32'h00000013; // NOP
    dut.Imm.mem[ 65] = 32'h00000013; // NOP
    dut.Imm.mem[ 66] = 32'h00A2A023; // sw a0,0(t0)
    dut.Imm.mem[ 67] = 32'h00000013; // NOP
    dut.Imm.mem[ 68] = 32'h00000013; // NOP
    dut.Imm.mem[ 69] = 32'h00B2A223; // sw a1,4(t0)
    dut.Imm.mem[ 70] = 32'h00000013; // NOP
    dut.Imm.mem[ 71] = 32'h00000013; // NOP
    dut.Imm.mem[ 72] = 32'h00600693; // li a3,6
    dut.Imm.mem[ 73] = 32'h00000013; // NOP
    dut.Imm.mem[ 74] = 32'h00000013; // NOP
    dut.Imm.mem[ 75] = 32'hFED42823; // sw a3,-16(s0)
    dut.Imm.mem[ 76] = 32'h00000013; // NOP
    dut.Imm.mem[ 77] = 32'h00000013; // NOP
    dut.Imm.mem[ 78] = 32'h00000693; // li a3,0
    dut.Imm.mem[ 79] = 32'h00000013; // NOP
    dut.Imm.mem[ 80] = 32'h00000013; // NOP
    dut.Imm.mem[ 81] = 32'hFED42C23; // sw a3,-8(s0)
    dut.Imm.mem[ 82] = 32'h00000013; // NOP
    dut.Imm.mem[ 83] = 32'h00000013; // NOP
    dut.Imm.mem[ 84] = 32'h2700006F; // j .L2
    dut.Imm.mem[ 85] = 32'h00000013; // NOP
    dut.Imm.mem[ 86] = 32'h00000013; // NOP
    // -- <.L6> (byte 348) --
    dut.Imm.mem[ 87] = 32'h00000693; // li a3,0
    dut.Imm.mem[ 88] = 32'h00000013; // NOP
    dut.Imm.mem[ 89] = 32'h00000013; // NOP
    dut.Imm.mem[ 90] = 32'hFED42A23; // sw a3,-12(s0)
    dut.Imm.mem[ 91] = 32'h00000013; // NOP
    dut.Imm.mem[ 92] = 32'h00000013; // NOP
    dut.Imm.mem[ 93] = 32'h1E00006F; // j .L3
    dut.Imm.mem[ 94] = 32'h00000013; // NOP
    dut.Imm.mem[ 95] = 32'h00000013; // NOP
    // -- <.L5> (byte 384) --
    dut.Imm.mem[ 96] = 32'hFF442683; // lw a3,-12(s0)
    dut.Imm.mem[ 97] = 32'h00000013; // NOP
    dut.Imm.mem[ 98] = 32'h00000013; // NOP
    dut.Imm.mem[ 99] = 32'h00269693; // slli a3,a3,2
    dut.Imm.mem[100] = 32'h00000013; // NOP
    dut.Imm.mem[101] = 32'h00000013; // NOP
    dut.Imm.mem[102] = 32'hFFC40613; // addi a2,s0,-4
    dut.Imm.mem[103] = 32'h00000013; // NOP
    dut.Imm.mem[104] = 32'h00000013; // NOP
    dut.Imm.mem[105] = 32'h00D606B3; // add a3,a2,a3
    dut.Imm.mem[106] = 32'h00000013; // NOP
    dut.Imm.mem[107] = 32'h00000013; // NOP
    dut.Imm.mem[108] = 32'hFD86A603; // lw a2,-40(a3)
    dut.Imm.mem[109] = 32'h00000013; // NOP
    dut.Imm.mem[110] = 32'h00000013; // NOP
    dut.Imm.mem[111] = 32'hFF442683; // lw a3,-12(s0)
    dut.Imm.mem[112] = 32'h00000013; // NOP
    dut.Imm.mem[113] = 32'h00000013; // NOP
    dut.Imm.mem[114] = 32'h00168693; // addi a3,a3,1
    dut.Imm.mem[115] = 32'h00000013; // NOP
    dut.Imm.mem[116] = 32'h00000013; // NOP
    dut.Imm.mem[117] = 32'h00269693; // slli a3,a3,2
    dut.Imm.mem[118] = 32'h00000013; // NOP
    dut.Imm.mem[119] = 32'h00000013; // NOP
    dut.Imm.mem[120] = 32'hFFC40593; // addi a1,s0,-4
    dut.Imm.mem[121] = 32'h00000013; // NOP
    dut.Imm.mem[122] = 32'h00000013; // NOP
    dut.Imm.mem[123] = 32'h00D586B3; // add a3,a1,a3
    dut.Imm.mem[124] = 32'h00000013; // NOP
    dut.Imm.mem[125] = 32'h00000013; // NOP
    dut.Imm.mem[126] = 32'hFD86A683; // lw a3,-40(a3)
    dut.Imm.mem[127] = 32'h00000013; // NOP
    dut.Imm.mem[128] = 32'h00000013; // NOP
    dut.Imm.mem[129] = 32'h12C6D663; // bge a3,a2,.L4
    dut.Imm.mem[130] = 32'h00000013; // NOP
    dut.Imm.mem[131] = 32'h00000013; // NOP
    dut.Imm.mem[132] = 32'hFF442683; // lw a3,-12(s0)
    dut.Imm.mem[133] = 32'h00000013; // NOP
    dut.Imm.mem[134] = 32'h00000013; // NOP
    dut.Imm.mem[135] = 32'h00269693; // slli a3,a3,2
    dut.Imm.mem[136] = 32'h00000013; // NOP
    dut.Imm.mem[137] = 32'h00000013; // NOP
    dut.Imm.mem[138] = 32'hFFC40613; // addi a2,s0,-4
    dut.Imm.mem[139] = 32'h00000013; // NOP
    dut.Imm.mem[140] = 32'h00000013; // NOP
    dut.Imm.mem[141] = 32'h00D606B3; // add a3,a2,a3
    dut.Imm.mem[142] = 32'h00000013; // NOP
    dut.Imm.mem[143] = 32'h00000013; // NOP
    dut.Imm.mem[144] = 32'hFD86A683; // lw a3,-40(a3)
    dut.Imm.mem[145] = 32'h00000013; // NOP
    dut.Imm.mem[146] = 32'h00000013; // NOP
    dut.Imm.mem[147] = 32'hFED42623; // sw a3,-20(s0)
    dut.Imm.mem[148] = 32'h00000013; // NOP
    dut.Imm.mem[149] = 32'h00000013; // NOP
    dut.Imm.mem[150] = 32'hFF442683; // lw a3,-12(s0)
    dut.Imm.mem[151] = 32'h00000013; // NOP
    dut.Imm.mem[152] = 32'h00000013; // NOP
    dut.Imm.mem[153] = 32'h00168693; // addi a3,a3,1
    dut.Imm.mem[154] = 32'h00000013; // NOP
    dut.Imm.mem[155] = 32'h00000013; // NOP
    dut.Imm.mem[156] = 32'h00269693; // slli a3,a3,2
    dut.Imm.mem[157] = 32'h00000013; // NOP
    dut.Imm.mem[158] = 32'h00000013; // NOP
    dut.Imm.mem[159] = 32'hFFC40613; // addi a2,s0,-4
    dut.Imm.mem[160] = 32'h00000013; // NOP
    dut.Imm.mem[161] = 32'h00000013; // NOP
    dut.Imm.mem[162] = 32'h00D606B3; // add a3,a2,a3
    dut.Imm.mem[163] = 32'h00000013; // NOP
    dut.Imm.mem[164] = 32'h00000013; // NOP
    dut.Imm.mem[165] = 32'hFD86A603; // lw a2,-40(a3)
    dut.Imm.mem[166] = 32'h00000013; // NOP
    dut.Imm.mem[167] = 32'h00000013; // NOP
    dut.Imm.mem[168] = 32'hFF442683; // lw a3,-12(s0)
    dut.Imm.mem[169] = 32'h00000013; // NOP
    dut.Imm.mem[170] = 32'h00000013; // NOP
    dut.Imm.mem[171] = 32'h00269693; // slli a3,a3,2
    dut.Imm.mem[172] = 32'h00000013; // NOP
    dut.Imm.mem[173] = 32'h00000013; // NOP
    dut.Imm.mem[174] = 32'hFFC40593; // addi a1,s0,-4
    dut.Imm.mem[175] = 32'h00000013; // NOP
    dut.Imm.mem[176] = 32'h00000013; // NOP
    dut.Imm.mem[177] = 32'h00D586B3; // add a3,a1,a3
    dut.Imm.mem[178] = 32'h00000013; // NOP
    dut.Imm.mem[179] = 32'h00000013; // NOP
    dut.Imm.mem[180] = 32'hFCC6AC23; // sw a2,-40(a3)
    dut.Imm.mem[181] = 32'h00000013; // NOP
    dut.Imm.mem[182] = 32'h00000013; // NOP
    dut.Imm.mem[183] = 32'hFF442683; // lw a3,-12(s0)
    dut.Imm.mem[184] = 32'h00000013; // NOP
    dut.Imm.mem[185] = 32'h00000013; // NOP
    dut.Imm.mem[186] = 32'h00168693; // addi a3,a3,1
    dut.Imm.mem[187] = 32'h00000013; // NOP
    dut.Imm.mem[188] = 32'h00000013; // NOP
    dut.Imm.mem[189] = 32'h00269693; // slli a3,a3,2
    dut.Imm.mem[190] = 32'h00000013; // NOP
    dut.Imm.mem[191] = 32'h00000013; // NOP
    dut.Imm.mem[192] = 32'hFFC40613; // addi a2,s0,-4
    dut.Imm.mem[193] = 32'h00000013; // NOP
    dut.Imm.mem[194] = 32'h00000013; // NOP
    dut.Imm.mem[195] = 32'h00D606B3; // add a3,a2,a3
    dut.Imm.mem[196] = 32'h00000013; // NOP
    dut.Imm.mem[197] = 32'h00000013; // NOP
    dut.Imm.mem[198] = 32'hFEC42603; // lw a2,-20(s0)
    dut.Imm.mem[199] = 32'h00000013; // NOP
    dut.Imm.mem[200] = 32'h00000013; // NOP
    dut.Imm.mem[201] = 32'hFCC6AC23; // sw a2,-40(a3)
    dut.Imm.mem[202] = 32'h00000013; // NOP
    dut.Imm.mem[203] = 32'h00000013; // NOP
    // -- <.L4> (byte 816) --
    dut.Imm.mem[204] = 32'hFF442683; // lw a3,-12(s0)
    dut.Imm.mem[205] = 32'h00000013; // NOP
    dut.Imm.mem[206] = 32'h00000013; // NOP
    dut.Imm.mem[207] = 32'h00168693; // addi a3,a3,1
    dut.Imm.mem[208] = 32'h00000013; // NOP
    dut.Imm.mem[209] = 32'h00000013; // NOP
    dut.Imm.mem[210] = 32'hFED42A23; // sw a3,-12(s0)
    dut.Imm.mem[211] = 32'h00000013; // NOP
    dut.Imm.mem[212] = 32'h00000013; // NOP
    // -- <.L3> (byte 852) --
    dut.Imm.mem[213] = 32'hFF042683; // lw a3,-16(s0)
    dut.Imm.mem[214] = 32'h00000013; // NOP
    dut.Imm.mem[215] = 32'h00000013; // NOP
    dut.Imm.mem[216] = 32'hFFF68613; // addi a2,a3,-1
    dut.Imm.mem[217] = 32'h00000013; // NOP
    dut.Imm.mem[218] = 32'h00000013; // NOP
    dut.Imm.mem[219] = 32'hFF842683; // lw a3,-8(s0)
    dut.Imm.mem[220] = 32'h00000013; // NOP
    dut.Imm.mem[221] = 32'h00000013; // NOP
    dut.Imm.mem[222] = 32'h40D606B3; // sub a3,a2,a3
    dut.Imm.mem[223] = 32'h00000013; // NOP
    dut.Imm.mem[224] = 32'h00000013; // NOP
    dut.Imm.mem[225] = 32'hFF442603; // lw a2,-12(s0)
    dut.Imm.mem[226] = 32'h00000013; // NOP
    dut.Imm.mem[227] = 32'h00000013; // NOP
    dut.Imm.mem[228] = 32'hDED648E3; // blt a2,a3,.L5
    dut.Imm.mem[229] = 32'h00000013; // NOP
    dut.Imm.mem[230] = 32'h00000013; // NOP
    dut.Imm.mem[231] = 32'hFF842683; // lw a3,-8(s0)
    dut.Imm.mem[232] = 32'h00000013; // NOP
    dut.Imm.mem[233] = 32'h00000013; // NOP
    dut.Imm.mem[234] = 32'h00168693; // addi a3,a3,1
    dut.Imm.mem[235] = 32'h00000013; // NOP
    dut.Imm.mem[236] = 32'h00000013; // NOP
    dut.Imm.mem[237] = 32'hFED42C23; // sw a3,-8(s0)
    dut.Imm.mem[238] = 32'h00000013; // NOP
    dut.Imm.mem[239] = 32'h00000013; // NOP
    // -- <.L2> (byte 960) --
    dut.Imm.mem[240] = 32'hFF042683; // lw a3,-16(s0)
    dut.Imm.mem[241] = 32'h00000013; // NOP
    dut.Imm.mem[242] = 32'h00000013; // NOP
    dut.Imm.mem[243] = 32'hFFF68693; // addi a3,a3,-1
    dut.Imm.mem[244] = 32'h00000013; // NOP
    dut.Imm.mem[245] = 32'h00000013; // NOP
    dut.Imm.mem[246] = 32'hFF842603; // lw a2,-8(s0)
    dut.Imm.mem[247] = 32'h00000013; // NOP
    dut.Imm.mem[248] = 32'h00000013; // NOP
    dut.Imm.mem[249] = 32'hD6D64CE3; // blt a2,a3,.L6
    dut.Imm.mem[250] = 32'h00000013; // NOP
    dut.Imm.mem[251] = 32'h00000013; // NOP
    dut.Imm.mem[252] = 32'h00000693; // li a3,0
    dut.Imm.mem[253] = 32'h00000013; // NOP
    dut.Imm.mem[254] = 32'h00000013; // NOP
    dut.Imm.mem[255] = 32'h00068513; // mv a0,a3
    dut.Imm.mem[256] = 32'h00000013; // NOP
    dut.Imm.mem[257] = 32'h00000013; // NOP
    dut.Imm.mem[258] = 32'hFFC40113; // addi sp,s0,-4
    dut.Imm.mem[259] = 32'h00000013; // NOP
    dut.Imm.mem[260] = 32'h00000013; // NOP
    dut.Imm.mem[261] = 32'h00012403; // lw s0,0(sp)
    dut.Imm.mem[262] = 32'h00000013; // NOP
    dut.Imm.mem[263] = 32'h00000013; // NOP
    dut.Imm.mem[264] = 32'h00412083; // lw ra,4(sp)
    dut.Imm.mem[265] = 32'h00000013; // NOP
    dut.Imm.mem[266] = 32'h00000013; // NOP
    dut.Imm.mem[267] = 32'h00810113; // addi sp,sp,8
    dut.Imm.mem[268] = 32'h00000013; // NOP
    dut.Imm.mem[269] = 32'h00000013; // NOP
    // -- <halt> (byte 1080) --
    dut.Imm.mem[270] = 32'h00000063; // HALT: beq x0,x0,0
    dut.Imm.mem[271] = 32'h00000013; // NOP
    dut.Imm.mem[272] = 32'h00000013; // NOP

    $display("[ICACHE] 91 insts, 273 slots, HALT byte PC=1080");
end
endtask

// ============================================================================
//  Task: load_dcache
//  .rodata (.LC0) → Dcache word 256..261 (byte 0x400..0x417)
//  ★ To change test input, modify words 256..261 ★
// ============================================================================
task load_dcache;
begin
    for (i = 0; i < 512; i = i + 1)
        dut.mm_stage_inst.Dmm.mem[i] = 32'h00000000;

    // .LC0 data → Dcache starting at word 256 (byte addr 0x400)
    // ★ Modify test data here ★
    dut.mm_stage_inst.Dmm.mem[256] = 32'h00000005; //  5
    dut.mm_stage_inst.Dmm.mem[257] = 32'hFFFFFFFF; // -1
    dut.mm_stage_inst.Dmm.mem[258] = 32'h00000002; //  2
    dut.mm_stage_inst.Dmm.mem[259] = 32'h00000004; //  4
    dut.mm_stage_inst.Dmm.mem[260] = 32'h0000000A; // 10
    dut.mm_stage_inst.Dmm.mem[261] = 32'h00000008; //  8

    // Save input snapshot
    for (i = 0; i < ARR_LEN; i = i + 1)
        input_snapshot[i] = dut.mm_stage_inst.Dmm.mem[256 + i];

    $display("[DCACHE] Input Data (.LC0 at word 256):");
    for (i = 0; i < ARR_LEN; i = i + 1)
        $display("  word[%0d] = %0d", 256+i, $signed(dut.mm_stage_inst.Dmm.mem[256+i]));
    $display("[DCACHE] Sorted results will be written to words %0d..%0d (stack area)",
             RESULT_WORD, RESULT_WORD+ARR_LEN-1);
end
endtask

// ============================================================================
//  Validation 1: Ascending Order Check (Results at Dcache word 180..185)
// ============================================================================
integer sorted_fail;
task check_sorted;
integer k;
reg signed [31:0] cur, nxt;
begin
    sorted_fail = 0;
    $display("\n  -- Validation 1: Ascending Order Check (Dcache word %0d..%0d)", RESULT_WORD, RESULT_WORD+ARR_LEN-1);
    $display("  idx | word | Sorted Result");
    $display("  ----|------|--------------");
    for (k = 0; k < ARR_LEN; k = k + 1)
        $display("  [%0d] | [%0d] |  %0d",
                 k, RESULT_WORD+k,
                 $signed(dut.mm_stage_inst.Dmm.mem[RESULT_WORD+k]));
    $display("  ----|------|--------------");
    for (k = 0; k < ARR_LEN-1; k = k + 1) begin
        cur = $signed(dut.mm_stage_inst.Dmm.mem[RESULT_WORD+k]);
        nxt = $signed(dut.mm_stage_inst.Dmm.mem[RESULT_WORD+k+1]);
        if (cur > nxt) begin
            $display("  [FAIL] word[%0d]=%0d > word[%0d]=%0d", RESULT_WORD+k, cur, RESULT_WORD+k+1, nxt);
            sorted_fail = sorted_fail + 1;
        end
    end
    if (sorted_fail == 0) $display("  Ascending Check: PASS ✓");
    else                  $display("  Ascending Check: FAIL ✗ (%0d errors)", sorted_fail);
end
endtask

// ============================================================================
//  Validation 2: Element Integrity (Permutation Check)
// ============================================================================
integer perm_fail;
task check_permutation;
integer j, k;
reg signed [31:0] val;
integer cnt_in, cnt_out;
begin
    perm_fail = 0;
    $display("\n  -- Validation 2: Element Integrity");
    for (j = 0; j < ARR_LEN; j = j + 1) begin
        val = $signed(input_snapshot[j]);
        cnt_in = 0; cnt_out = 0;
        for (k = 0; k < ARR_LEN; k = k + 1) begin
            if ($signed(input_snapshot[k])                    === val) cnt_in  = cnt_in  + 1;
            if ($signed(dut.mm_stage_inst.Dmm.mem[RESULT_WORD+k]) === val) cnt_out = cnt_out + 1;
        end
        if (cnt_in !== cnt_out) begin
            $display("  [FAIL] Element %0d: Input Count=%0d, Output Count=%0d", val, cnt_in, cnt_out);
            perm_fail = perm_fail + 1;
        end
    end
    if (perm_fail == 0) $display("  Element Integrity: PASS ✓");
    else                $display("  Element Integrity: FAIL ✗ (%0d elements)", perm_fail);
end
endtask

// ============================================================================
//  Debug: Key Registers
// ============================================================================
task dump_regs;
begin
    $display("\n--- Registers (cycle=%0d) ---", cycle_cnt);
    $display("  sp(x2)  = 0x%08h (%0d)", dut.id_stage_inst.u_reg_files.regs[2],
                                           $signed(dut.id_stage_inst.u_reg_files.regs[2]));
    $display("  s0(x8)  = 0x%08h (%0d)", dut.id_stage_inst.u_reg_files.regs[8],
                                           $signed(dut.id_stage_inst.u_reg_files.regs[8]));
    $display("  a2(x12) = %0d", $signed(dut.id_stage_inst.u_reg_files.regs[12]));
    $display("  a3(x13) = %0d", $signed(dut.id_stage_inst.u_reg_files.regs[13]));
end
endtask

// ============================================================================
//  Main Simulation
// ============================================================================
reg halt_detected;
integer cyc;

initial begin
    $display("========================================================");
    $display("  RV32I Pipeline - GCC Bubble Sort (rv32i_asm.py)");
    $display("  HALT byte PC=1080  Result Dcache[%0d..%0d]",
             RESULT_WORD, RESULT_WORD+ARR_LEN-1);
    $display("========================================================");

    rst = 1; halt_detected = 0;
    @(posedge clk); #1;
    @(posedge clk); #1;

    load_icache;
    load_dcache;

    @(posedge clk); #1;
    rst = 0;
    $display("\n[cycle %0d] Reset released, starting execution...", cycle_cnt);

    begin : run_loop
        for (cyc = 0; cyc < MAX_CYCLES; cyc = cyc + 1) begin
            @(posedge clk); #1;
            if (dut.pc_if === HALT_BYTE_PC && !halt_detected) begin
                halt_detected = 1;
                $display("\n[cycle %0d] ★ HALT reached (pc_if=%0d)", cycle_cnt, dut.pc_if);
                repeat(8) @(posedge clk);
                disable run_loop;
            end
        end
    end

    if (!halt_detected)
        $display("\n[WARN] Timeout! HALT not reached within %0d cycles", MAX_CYCLES);

    $display("\n========== Sorting Result Validation (cycle=%0d) ==========\n", cycle_cnt);
    check_sorted;
    check_permutation;

    $display("\n========================================================");
    if (sorted_fail == 0 && perm_fail == 0)
        $display("  ★  ALL PASSED  ★");
    else begin
        $display("  ✗  FAILED");
        dump_regs;
    end
    $display("  Total Simulation Cycles: %0d", cycle_cnt);
    $display("========================================================\n");
    $finish;
end

always @(posedge clk)
    if (!rst && dut.wb_wreg_out === 1'bx)
        $display("[WARN] X-State detected: wb_wreg_out cycle=%0d", cycle_cnt);

endmodule